- minVal = minVal || 4
- offset = offset || -25
- stroke = stroke || 20
- styles = styles || true

- const values = (sort ? [...data].sort((a, b) => a < b ? 1 : -1) : data)
- const radius = (100 - stroke) / 2
- const π = Math.PI
- const sum = data.reduce((m, v) => m + v, 0)

- const format = (v) => +v.toFixed(0)
- const percent = (v) => +v.toFixed(2) + "%"
- const rotate = (v) => percent(v * π * (radius / 50))

svg(
  xmlns="http://www.w3.org/2000/svg"
  width=200 height=200
)
  if styles
    defs
      style.
        svg { overflow: visible }
        text { text-anchor: middle; transform: translateY(0.33em); }
        .segment-arc { fill: none; }
        .segment-arc-#{stroke} { stroke-width: #{percent(stroke)} }

  if title
    title= title

  if description
    desc= description

  svg(x="50%" y="50%" role="presentation")
    if title && stroke < 50
      text(role="presentation")
        = title

    each value in values
      - var i = data.indexOf(value)
      - var v = value / sum * 100
      - var t = i / (data.length - 1)
      - var key = ("0" + (~~(t * 255)).toString(16)).slice(-2)
      - var dashoffset = -offset
      - var dasharray = [v, 100 - v]

      - var theta = π * 2 * ((offset + v / 2) / 100)
      - var scale = stroke === 50 && v < 25 ? 1.2 : 1

      - var x = Math.cos(theta) * scale * radius
      - var y = Math.sin(theta) * scale * radius

      - offset += v

      g.segment(
        class=`segment-${key}`
        aria-label=`${format(v)}%`
        aria-description=i
      )
        circle.segment-arc(
          class=`segment-arc-${stroke}`
          r=percent(radius)
          stroke-dashoffset=rotate(dashoffset)
          stroke-dasharray=dasharray.map(rotate).join(" ")
          stroke=colors && colors[i]
          role="presentation"
        )

        if v > minVal
          text.segment-label(
            x=percent(x) y=percent(y)
            role="presentation"
          )
            = format(v)
